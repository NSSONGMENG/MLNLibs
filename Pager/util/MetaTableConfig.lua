---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by song.meng
--- DateTime: 2019/8/10 上午10:06
---

--- 针对元表所做修改如下：
--- 新增方法
--- 1、setConfig(table)     通过table设置各属性，key为方法名，value为参数
--- 2、superView()          新增方法，因superview写法不符合惯例
--- 3、allSubviews()        无序返回所有子视图列表
--- 4、addViews(v1, v2)     支持一次性添加多个view
--- 5、avatar(头像短链)      支持给image view设置短链地址

--- 修改方法
--- 1、addView(t/v)         支持以table作为参数（table.contentView必须为userdata）
--- 2、removeFromSuper()
--- 3、superview()          因iOS存在window被移除导致白屏的封线，此方法屏蔽了原生实现

--- 通过__SUPER_VIEW和__SUB_VIEW两个全局表记录视图的父子关系，因此解决了local在iOS上被释放的现象，可以放心使用local视图


local unpackParam = function (list)
    if type(list) ~= 'table' then return list end
    if type(table.unpack) == 'function' then return table.unpack(list) end
    if type(unpack) == 'function' then return unpack(list) end

    local cnt = 0
    for i, v in pairs(list) do
        cnt = math.max(cnt, i)
    end

    if cnt == 0 then return nil end
    if cnt == 1 then return list[1] end
    if cnt == 2 then return list[1], list[2] end
    if cnt == 3 then return list[1], list[2], list[3] end
    if cnt == 4 then return list[1], list[2], list[3], list[4] end
    if cnt == 5 then return list[1], list[2], list[3], list[4], list[5] end
    if cnt == 6 then return list[1], list[2], list[3], list[4], list[5], list[6] end
end

-- 存储view的subviews， 父view作为key，{view, view2}作为value
__SUB_VIEW = {}
-- 存储view的super view，子view作为key
__SUPER_VIEW = {}

---
--- 原表处理
---
---@param   _               table       默认参数，根据以下语境为__preconfig这个表
---@param   userdataView    userdata    待处理的对象，因为无法直接取到用户数据的类，因此需根据对象处理对象所属类
---@param   name            string      自定义view的根视图名称必须统一成'name'，默认为contentView
---
local function __functionRep(_,userdataView, name)
    name = name or "contentView"
    repeat
        if type(userdataView) ~= "userdata" then break end
        local mt = getmetatable(userdataView)
        if type(mt) == "nil" then break end

        -- 支持通过table设置参数，避免调用不存在的方法报错
        repeat
            if mt["setConfig"] ~= nil then break end

            mt["setConfig"] = function(t, conf)
                for k, v in pairs(conf) do
                    if t[k] then
                        t[k](t, unpackParam(v))
                    else
                        print(t,"has no method named:", k, "value is:", v)
                    end
                end
                return t
            end
        until(1)

        -- 替换addView方法，兼容传table作为参数
        repeat
            if mt["addView"] == nil or mt["_oriAddView"] ~= nil then break end
            local oriFunc = mt["addView"]
            local newFunc = function(t, v)
                local list = __SUB_VIEW[t] or {}
                if type(v) == "userdata" then
                    mt["_oriAddView"](t, v)
                    __SUPER_VIEW[v] = t
                    list[v] = true
                elseif type(v) == "table" and type(v[name]) == "userdata" then
                    mt["_oriAddView"](t, v[name])
                    list[v[name]] = true
                    __SUPER_VIEW[v[name]] = t
                else
                    print(v, "is not a table, or it has no content view named：", name)
                end
                __SUB_VIEW[t] = list
                return t
            end

            mt["addView"] = newFunc
            mt["_oriAddView"] = oriFunc
        until(1)

        -- 添加addViews方法，支持一次性添加多个view
        repeat
            if mt["addView"] == nil or mt["addViews"] ~= nil then break end
            mt["addViews"] = function(t, ...)
                local list = {...}
                for _, v in ipairs(list) do
                    mt["addView"](t, v)
                end
                return t
            end
        until(1)

        -- 修改inserView
        repeat
            if mt["insertView"] == nil or mt["_oriInsertView"] ~= nil then break end
            local oriFunc = mt["insertView"]
            local newFunc = function(t, v, idx)
                local list = __SUB_VIEW[t] or {}
                if type(v) == "userdata" then
                    mt["_oriInsertView"](t, v, idx)
                    __SUPER_VIEW[v] = t
                    list[v] = true
                elseif type(v) == "table" and type(v[name]) == "userdata" then
                    mt["_oriInsertView"](t, v[name], idx)
                    list[v[name]] = true
                    __SUPER_VIEW[v[name]] = t
                else
                    print(v, "is not a table, or it has no content view named：", name)
                end
                __SUB_VIEW[t] = list
                return t
            end

            mt["insertView"] = newFunc
            mt["_oriInsertView"] = oriFunc
        until(1)

        -- 修改removeFromSuper方法
        repeat
            if mt["removeFromSuper"] == nil or mt["_oriRemoveFromSuper"] ~= nil then break end
            local oriFunc = mt["removeFromSuper"]
            local newFunc = function(t)
                local super = __SUPER_VIEW[t]
                if super then
                    local sub = __SUB_VIEW[super]
                    sub = sub or {}
                    sub[t] = nil
                    mt["_oriRemoveFromSuper"](t)
                    __SUPER_VIEW[t] = nil
                end
                return t
            end
            mt["removeFromSuper"] = newFunc
            mt["_oriRemoveFromSuper"] = oriFunc
        until(1)

        -- 修改removeAllSubviews方法
        repeat
            if mt["removeAllSubviews"] == nil or mt["_oriRemoveAllSubviews"] == nil then break end
            local oriFunc = mt["removeAllSubviews"]
            local newFunc = function(t)
                local list = __SUB_VIEW[t]
                for _, v in ipairs(list) do
                    __SUB_VIEW[v] = nil
                end
                __SUB_VIEW[t] = nil
                mt["_oriRemoveAllSubviews"](t)
            end

            mt["removeAllSubviews"] = newFunc
            mt["_oriRemoveAllSubviews"] = oriFunc
        until(1)

        -- 新增allSubviews方法
        repeat
            if mt["addView"] == nil or mt["allSubviews"] ~= nil then break end
            local func = function(t)
                local subViews = __SUB_VIEW[t] or {}
                local list = {}
                for _, v in pairs(subViews) do
                    table.insert(list, v)
                end
                return list
            end
            mt["allSubviews"] = func
        until(1)

        -- 添加superView方法（桥接写成了superview()）
        repeat
            if mt["superview"] == nil or mt["superView"] ~= nil then break end

            mt["superView"] = function(t)
                return __SUPER_VIEW[t]
            end
            mt["superview"] = function(t)
                return __SUPER_VIEW[t]
            end
        until(1)

        -- 给ImageView添加方法
        repeat
            if mt["image"] == nil or mt["avatar"] ~= nil then return end
            mt["avatar"] = function(t, url, isBigPhoto)
                if type(url) ~= "string" then
                    print("avatar url is not string:", url)
                    return t
                else
                    if string.match(url, "http") == "http" then
                        mt["image"](t, url)
                    else
                        local prefix = "https://img.momocdn.com/album/"
                        local tail = "_S.jpg"
                        if isBigPhoto then
                            tail = "_L.jpg"
                        end
                        url = table.concat({prefix, string.sub(url, 1, 2), "/", string.sub(url, 3, 4), "/", url, tail})
                        mt["image"](t, url)
                    end
                    return t
                end
            end
        until(1)
    until(1)
end

local __preconfig = setmetatable({}, {__call = __functionRep})

__preconfig(window)
__preconfig(View())
__preconfig(Label())
__preconfig(EditTextView())
__preconfig(LinearLayout())
__preconfig(AnimationZone())
__preconfig(ImageView())
__preconfig(ScrollView())






---
--- 注：bridge或SDK提供的类似于View、Label、TableView等是各组件的实例化方法对应的地址，不能作为Class使用
--- 如：type('View')的返回结果是function，可见'View'只是实例化view的函数地址而已，而不是类
---
--- 与原生的方法交换有些差异，在新方法中调用自己会造成死循环，如在新的addView()方法中，需要使用ori_addView()才能调到原始的方法
---

---
--- 通过对象实现方法【交】换（适用于对通过桥接或SDK提供的类进行操作）
---
---@param obj           userdata / table
---@param oriFuncName   string
---@param newFunc       function
---@return  boolean 操作是否成功
---
function swizz_sdk_method(obj, oriFuncName, newFunc)
    if type(obj) ~= 'userdata' or type(oriFuncName) ~= 'string' or type(newFunc) ~= 'function' then return false end
    local mt = getmetatable(obj)
    if type(mt) ~= 'table' or type(mt[oriFuncName]) == 'nil' then return false end

    local oriFunc = mt[oriFuncName]
    mt[oriFuncName] = newFunc
    mt['ori_' .. oriFuncName] = oriFunc
    return true
end

---
--- 通过对象实现方法【替】换（适用于对通过桥接或SDK提供的类进行操作）
--- 若有oriFuncName对应的方法则覆盖，否则将添加
---
---@param obj           userdata / table
---@param oriFuncName   string
---@param newFunc       function
---@return  boolean 操作是否成功
---
function replace_sdk_method(obj, oriFuncName, newFunc)
    if type(obj) ~= 'userdata' or type(oriFuncName) ~= 'string' or type(newFunc) ~= 'function' then return false end
    local mt = getmetatable(obj)
    if type(mt) ~= 'table' then return false end

    mt[oriFuncName] = newFunc
    return true
end

---
--- 通过类实现方法【交】换 （使用于Lua自定义类）
---
---@param class         table   Lua类
---@param oriFuncName   string
---@param newFunc       function
---@return  boolean 操作是否成功
---
function swizz_lua_method(class, oriFuncName, newFunc)
    if type(class) ~= 'table'
            or type(oriFuncName) ~= 'string'
            or type(newFunc) ~= 'function'
            or type(class[oriFuncName]) == 'nil' then
        return false
    end

    local oriFunc = class[oriFuncName]
    class[oriFuncName] = newFunc
    class['ori_' .. oriFuncName] = oriFunc
    return true
end

---
--- 通过类实现方法【替】换 （使用于Lua自定义类）
--- 若有oriFuncName对应的方法则覆盖，否则将添加
---
---@param class         table   Lua类
---@param oriFuncName   string
---@param newFunc       function
---@return  boolean 操作是否成功
---
function replace_lua_method(class,oriFuncName, newFunc)
    if type(class) ~= 'table'
            or type(oriFuncName) ~= 'string'
            or type(newFunc) ~= 'function' then
        return false
    end

    class[oriFuncName] = newFunc
    return true
end
